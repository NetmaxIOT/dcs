/* dcs-object.c generated by valac 0.32.1, the Vala compiler
 * generated from dcs-object.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define DCS_TYPE_OBJECT (dcs_object_get_type ())
#define DCS_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), DCS_TYPE_OBJECT, DcsObject))
#define DCS_IS_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), DCS_TYPE_OBJECT))
#define DCS_OBJECT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), DCS_TYPE_OBJECT, DcsObjectIface))

typedef struct _DcsObject DcsObject;
typedef struct _DcsObjectIface DcsObjectIface;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_param_spec_unref0(var) ((var == NULL) ? NULL : (var = (g_param_spec_unref (var), NULL)))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))

struct _DcsObjectIface {
	GTypeInterface parent_iface;
	gboolean (*equal) (DcsObject* self, DcsObject* a, DcsObject* b);
	gint (*compare) (DcsObject* self, DcsObject* a);
	gchar* (*to_string) (DcsObject* self);
	const gchar* (*get_id) (DcsObject* self);
	void (*set_id) (DcsObject* self, const gchar* value);
};



GType dcs_object_get_type (void) G_GNUC_CONST;
gboolean dcs_object_equal (DcsObject* self, DcsObject* a, DcsObject* b);
static gboolean dcs_object_real_equal (DcsObject* self, DcsObject* a, DcsObject* b);
const gchar* dcs_object_get_id (DcsObject* self);
gint dcs_object_compare (DcsObject* self, DcsObject* a);
static gint dcs_object_real_compare (DcsObject* self, DcsObject* a);
gchar* dcs_object_to_string (DcsObject* self);
static gchar* dcs_object_real_to_string (DcsObject* self);
void dcs_object_set_id (DcsObject* self, const gchar* value);


/**
     * Specifies whether the objects provided are equivalent for sorting.
     *
     * @param a one of the objects to use in the comparison.
     * @param b the other object to use in the comparison.
     *
     * @return  ``true`` or ``false`` depending on whether or not the id
     *          parameters match
     */
static gboolean dcs_object_real_equal (DcsObject* self, DcsObject* a, DcsObject* b) {
	gboolean result = FALSE;
	DcsObject* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	DcsObject* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	g_return_val_if_fail (a != NULL, FALSE);
	g_return_val_if_fail (b != NULL, FALSE);
	_tmp0_ = a;
	_tmp1_ = dcs_object_get_id (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = b;
	_tmp4_ = dcs_object_get_id (_tmp3_);
	_tmp5_ = _tmp4_;
	result = g_strcmp0 (_tmp2_, _tmp5_) == 0;
	return result;
}


gboolean dcs_object_equal (DcsObject* self, DcsObject* a, DcsObject* b) {
	g_return_val_if_fail (self != NULL, FALSE);
	return DCS_OBJECT_GET_INTERFACE (self)->equal (self, a, b);
}


/**
     * Compares the object to another that is provided.
     *
     * @param a the object to compare this one against.
     *
     * @return  ``0`` if they contain the same id, ``1`` otherwise
     */
static gint dcs_object_real_compare (DcsObject* self, DcsObject* a) {
	gint result = 0;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	DcsObject* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	_tmp0_ = dcs_object_get_id (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = a;
	_tmp3_ = dcs_object_get_id (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_ascii_strcasecmp (_tmp1_, _tmp4_);
	result = _tmp5_;
	return result;
}


gint dcs_object_compare (DcsObject* self, DcsObject* a) {
	g_return_val_if_fail (self != NULL, 0);
	return DCS_OBJECT_GET_INTERFACE (self)->compare (self, a);
}


/**
     * Print all properties of the object.
     */
static gpointer _g_param_spec_ref0 (gpointer self) {
	return self ? g_param_spec_ref (self) : NULL;
}


static gchar* dcs_object_real_to_string (DcsObject* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	GType type = 0UL;
	GType _tmp1_ = 0UL;
	GObjectClass* ocl = NULL;
	GType _tmp2_ = 0UL;
	GTypeClass* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	GType _tmp5_ = 0UL;
	const gchar* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	const gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	GObjectClass* _tmp18_ = NULL;
	guint _tmp19_;
	GParamSpec** _tmp20_ = NULL;
	_tmp0_ = g_strdup ("");
	_result_ = _tmp0_;
	_tmp1_ = G_TYPE_FROM_INSTANCE ((GObject*) self);
	type = _tmp1_;
	_tmp2_ = type;
	_tmp3_ = g_type_class_ref (_tmp2_);
	ocl = (GObjectClass*) _tmp3_;
	_tmp4_ = _result_;
	_tmp5_ = type;
	_tmp6_ = g_type_name (_tmp5_);
	_tmp7_ = dcs_object_get_id (self);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_strdup_printf ("[%s(@id=%s)]\n", _tmp6_, _tmp8_);
	_tmp10_ = _tmp9_;
	_tmp11_ = g_strconcat (_tmp4_, _tmp10_, NULL);
	_g_free0 (_result_);
	_result_ = _tmp11_;
	_g_free0 (_tmp10_);
	_tmp12_ = _result_;
	_tmp13_ = g_strconcat (_tmp12_, " Properties:\n", NULL);
	_g_free0 (_result_);
	_result_ = _tmp13_;
	_tmp14_ = _result_;
	_tmp15_ = g_strdup_printf (" %-24s%-35s%-24s%-20s\n", "Name:", "Value:", "Value Type:", "Owner Type:");
	_tmp16_ = _tmp15_;
	_tmp17_ = g_strconcat (_tmp14_, _tmp16_, NULL);
	_g_free0 (_result_);
	_result_ = _tmp17_;
	_g_free0 (_tmp16_);
	_tmp18_ = ocl;
	_tmp20_ = g_object_class_list_properties (_tmp18_, &_tmp19_);
	{
		GParamSpec** spec_collection = NULL;
		gint spec_collection_length1 = 0;
		gint _spec_collection_size_ = 0;
		gint spec_it = 0;
		spec_collection = _tmp20_;
		spec_collection_length1 = _tmp19_;
		for (spec_it = 0; spec_it < _tmp19_; spec_it = spec_it + 1) {
			GParamSpec* _tmp21_ = NULL;
			GParamSpec* spec = NULL;
			_tmp21_ = _g_param_spec_ref0 (spec_collection[spec_it]);
			spec = _tmp21_;
			{
				gchar* value = NULL;
				GType ptype = 0UL;
				GParamSpec* _tmp22_ = NULL;
				GType _tmp23_ = 0UL;
				gchar* name = NULL;
				GParamSpec* _tmp24_ = NULL;
				const gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				GValue number = {0};
				GType _tmp27_ = 0UL;
				GValue _tmp28_ = {0};
				const gchar* _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				GParamSpec* _tmp31_ = NULL;
				const gchar* _tmp32_ = NULL;
				gchar* _tmp33_ = NULL;
				gchar* _tmp34_ = NULL;
				GParamSpec* _tmp35_ = NULL;
				GType _tmp36_ = 0UL;
				const gchar* _tmp37_ = NULL;
				GParamSpec* _tmp38_ = NULL;
				GType _tmp39_ = 0UL;
				const gchar* _tmp40_ = NULL;
				gchar* _tmp41_ = NULL;
				gchar* _tmp42_ = NULL;
				gchar* _tmp43_ = NULL;
				_tmp22_ = spec;
				_tmp23_ = _tmp22_->value_type;
				ptype = _tmp23_;
				_tmp24_ = spec;
				_tmp25_ = g_param_spec_get_name (_tmp24_);
				_tmp26_ = g_strdup (_tmp25_);
				name = _tmp26_;
				_tmp27_ = ptype;
				g_value_init (&_tmp28_, _tmp27_);
				number = _tmp28_;
				_tmp29_ = name;
				g_object_get_property ((GObject*) self, _tmp29_, &number);
				_tmp30_ = _result_;
				_tmp31_ = spec;
				_tmp32_ = g_param_spec_get_name (_tmp31_);
				_tmp33_ = g_strdup_value_contents (&number);
				_tmp34_ = _tmp33_;
				_tmp35_ = spec;
				_tmp36_ = _tmp35_->value_type;
				_tmp37_ = g_type_name (_tmp36_);
				_tmp38_ = spec;
				_tmp39_ = _tmp38_->owner_type;
				_tmp40_ = g_type_name (_tmp39_);
				_tmp41_ = g_strdup_printf (" %-24s%-35s%-24s%-20s\n", _tmp32_, _tmp34_, _tmp37_, _tmp40_);
				_tmp42_ = _tmp41_;
				_tmp43_ = g_strconcat (_tmp30_, _tmp42_, NULL);
				_g_free0 (_result_);
				_result_ = _tmp43_;
				_g_free0 (_tmp42_);
				_g_free0 (_tmp34_);
				G_IS_VALUE (&number) ? (g_value_unset (&number), NULL) : NULL;
				_g_free0 (name);
				_g_free0 (value);
				_g_param_spec_unref0 (spec);
			}
		}
		spec_collection = (g_free (spec_collection), NULL);
	}
	result = _result_;
	_g_type_class_unref0 (ocl);
	return result;
}


gchar* dcs_object_to_string (DcsObject* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return DCS_OBJECT_GET_INTERFACE (self)->to_string (self);
}


const gchar* dcs_object_get_id (DcsObject* self) {
	g_return_val_if_fail (self != NULL, NULL);
	return DCS_OBJECT_GET_INTERFACE (self)->get_id (self);
}


void dcs_object_set_id (DcsObject* self, const gchar* value) {
	g_return_if_fail (self != NULL);
	DCS_OBJECT_GET_INTERFACE (self)->set_id (self, value);
}


static void dcs_object_base_init (DcsObjectIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
		/**
		     * The identifier for the object.
		     */
		g_object_interface_install_property (iface, g_param_spec_string ("id", "id", "id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
		iface->equal = dcs_object_real_equal;
		iface->compare = dcs_object_real_compare;
		iface->to_string = dcs_object_real_to_string;
	}
}


GType dcs_object_get_type (void) {
	static volatile gsize dcs_object_type_id__volatile = 0;
	if (g_once_init_enter (&dcs_object_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DcsObjectIface), (GBaseInitFunc) dcs_object_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType dcs_object_type_id;
		dcs_object_type_id = g_type_register_static (G_TYPE_INTERFACE, "DcsObject", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (dcs_object_type_id, G_TYPE_OBJECT);
		g_once_init_leave (&dcs_object_type_id__volatile, dcs_object_type_id);
	}
	return dcs_object_type_id__volatile;
}



